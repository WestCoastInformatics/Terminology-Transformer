package com.wci.tt.jpa.loaders;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.log4j.Logger;

import com.wci.tt.SourceData;
import com.wci.tt.SourceDataConverter;
import com.wci.tt.helpers.ConverterStatus;
import com.wci.tt.helpers.LocalException;
import com.wci.tt.jpa.services.ContentServiceJpa;
import com.wci.tt.jpa.services.SourceDataServiceJpa;
import com.wci.tt.services.ContentService;
import com.wci.tt.services.SourceDataService;

/**
 * Converter for RxNorm files
 */
public class CustomLoaderRrfUmls implements SourceDataConverter {

  /** The name. */
  private String name;

  /**
   * Gets the name.
   *
   * @return the name
   */
  @Override
  public String getName() {
    return this.name;
  }

  /**
   * Sets the name.
   *
   * @param name the new name
   */
  @Override
  public void setName(String name) {
    this.name = name;
  }

  /**
   * Convert.
   * @throws Exception
   */
  @Override
  public void convert(SourceData sourceData)
    throws Exception {

    // check pre-requisites
    if (sourceData.getSourceDataFiles().size() == 0) {
      throw new Exception(
          "No source data files specified for source data object "
              + sourceData.getName());
    }
    if (sourceData.getConverterName().isEmpty()) {
      throw new Exception(
          "No source data converter specified for source data object "
              + sourceData.getName());
    }
 
    
    // find the data directory from the first sourceDataFile
    String inputDir = sourceData.getSourceDataFiles().get(0).getPath();
    
    if (new File(inputDir).isDirectory()) {
      throw new LocalException("Source data directory is not a directory: " + inputDir);
    }

    SourceDataService sourceDataService = new SourceDataServiceJpa();
    sourceData.setConverterStatus(ConverterStatus.CONVERTING);
    sourceDataService.updateSourceData(sourceData);

    ContentService contentService = new ContentServiceJpa();
    try {
      // load RRF multiple-part terminology, with terminology/version of data
      // files as terminology, source data name as version
      // goal is to allow easy searching of content based on source files, as
      // well as terminology/version
      SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
      
      contentService.loadRrfTerminology(sourceData.getName(),
          sdf.format(new Date()), false, inputDir);
      sourceData.setConverterStatus(ConverterStatus.CONVERTED);
    } catch (Exception e) {
      Logger.getLogger(this.getClass())
          .error("Error converting source data for " + sourceData.getName()
              + " using converter " + this.getName());

      sourceData.setConverterStatus(ConverterStatus.FAILED);
    } finally {
      sourceDataService.updateSourceData(sourceData);
      contentService.close();
      sourceDataService.close();
    }
  }
}
